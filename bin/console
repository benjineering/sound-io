#!/usr/bin/env ruby

require 'bundler/setup'
require 'sound_io'

SECONDS_OFFSET = 0

sio = SoundIO::Context.new
sio.connect
sio.flush_events

out_dev = sio.output_device
raise 'No output device' if out_dev.nil?

out_stream = out_dev.create_stream(format: :float32be)

# static void write_callback(struct SoundIoOutStream *outstream, int frame_count_min, int frame_count_max)
out_stream.write_callback do |out_stream, frame_count_min, frame_count_max|
  channel_layout = out_stream.layout
  sample_rate = outstream.sample_rate
  secs_per_frame = 1.0 / sample_rate
  areas = nil # ?
  frames_left = frame_count_max
  err = nil # ?

  while frames_left > 0
    frame_count = frames_left

    if ((err = soundio_outstream_begin_write(outstream, &areas, &frame_count))) {
      fprintf(stderr, "%s\n", soundio_strerror(err));
      exit(1);
    }

    if (!frame_count)
      break;

    float pitch = 440.0f;
    float radians_per_second = pitch * 2.0f * PI;

    for (int frame = 0; frame < frame_count; frame += 1) {
      float sample = sin((seconds_offset + frame * seconds_per_frame) * radians_per_second);

      for (int channel = 0; channel < layout->channel_count; channel += 1) {
        float *ptr = (float*)(areas[channel].ptr + areas[channel].step * frame);
        *ptr = sample;
      }
    }
    
    seconds_offset = fmod(seconds_offset + seconds_per_frame * frame_count, 1.0);

    if ((err = soundio_outstream_end_write(outstream))) {
      fprintf(stderr, "%s\n", soundio_strerror(err));
      exit(1);
    }

    frames_left -= frame_count;
  end
end

# TODO: combine open and start
out_stream.open
out_stream.start

# TODO: eternal loop?
# for (;;)
#   soundio_wait_events(soundio);
